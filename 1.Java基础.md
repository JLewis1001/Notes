[Java核心技术 卷I]()  
[深入理解Android Java虚拟机ART]()  
[Linux进程同步机制-Futex](https://cloud.tencent.com/developer/article/1176832)  
[Java volatile深入解析](https://zhuanlan.zhihu.com/p/43526907)  
[一次深入骨髓的 volatile 研究](https://zhuanlan.zhihu.com/p/144712930)  
[Java魔法类：Unsafe应用解析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)  
[从ReentrantLock的实现看AQS的原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)  


[TOC]  

# Java基础

## Java多线程同步

### 1. synchronized实现原理  
分5层逐步解析synchronized的工作原理：Java代码实现，字节码实现，JVM实现，操作系统实现，CPU实现（汇编指令）；  


#### 1.1 Java代码实现
1. sychronized的定义及使用场景：  
Java提供的一种支持原子性的锁机制，可以保证多线程并发访问共享数据时是互斥的；sychronized是互斥锁，同一时刻最多只有一个线程能持有这个锁，所以被sychronized修饰的代码块可以以不可分割的方式被执行；由于synchronized机制悲观地认为，自己在使用数据的时候一定有其他线程来修改数据，所以synchronized是一种悲观锁；  
    > 注释：锁定的是对象而不是代码：执行某一段代码时必须锁定某个对象；  
2. 示例代码：  
    ```java
    private static Thread[] threads = new Thread[10000];
    private static int count = 0;
    
    public static void main(String[] args) {
        Object o = new Object();
        Runnable runnable = () -> {
        //    synchronized (o) {
            for (int i = 0; i < 100_0000; i++) {
                count++;
            }
        //    }
        };

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(runnable);
        }

        for (Thread t : threads) {
            t.start();
        }
        try {
            for (Thread t : threads) {
                t.join();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("lewis : count is " + count);
    }
    ```  
    > 如果不加synchronized修饰，打印出来的count!=10000\*100_0000；发生这种问题的底层的原因涉及到Java线程内存模型；  
3. 简单了解一下Java线程的内存模型：  
    - CPU硬件结构如图所示：  
    ![CPU硬件结构](https://github.com/JQLewis/Notes/blob/main/1-pics/CPU%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.png?raw=true)  
    - CPU在读取运算所需的数据、存储运算得到的数据结果等操作的时候，会涉及到与内存的读写交互，但CPU元算速度远高于内存的读写速度，为了解决这种速度不匹配的情况，增加了多级高速缓存；这样，运算前，将数据复制到高速缓存，运算后，将结果同步写回主存（对于JVM来说，这个主存是指Java堆内存）；  
    - CPU在计算时，并不总是从主存中读数据（数据是指共享变量，存在线程间共享和竞争的关系），而是通过从多级缓存中拿数据，从而提高执行效率。读取数据的优先级是：寄存器 > 高速缓存(多级) > 主存；  
    - 所以线程的工作内存是个抽象概念，指的是寄存器和（多级）高速缓存，线程的工作内存中保存的是主存中数据的备份；  
    - 当多线程访问主存中的某个经常被访问的数据时，是先从线程的工作内存中读写数据，然后在某个合适的时候再写回主存中，所以每个工作线程中的副本变量不一定是最新的（对其他线程是不可见的），这就是上面多线程读写count字段出现线程不安全的原因；  
    ![Java线程内存模型](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png?raw=true)  
    - 所以需要加锁保证多线程间数据同步，简单说一下（后续介绍），volatile字段的作用只能保证数据的可见性，即：线程A对volatile count字段执行写操作后，会立即将count值写回到主存中，这样其他线程对count就是可见的了，但是volatile并不会保证操作的原子性；  




4. sychronized的4种使用方式：  
    ```java
    public class Foo {
        private int count = 0;
        private Object o = new Object();
    
        public static synchronized void t1() {
            // 静态方法加synchronized和t2()的方式争用的都是类锁，和对象锁唯一的区别就是，内存中类锁只有一把；
        }
    
        public void t2() {
            synchronized (Foo.class) {
            }
        }
    
        public synchronized void t3() {
        }
    
        public void t4() {
            synchronized (this) {
            }
        }
    
        public void t5() {
            // 如果使用下面的o对象，多线程并发访问t5()，结果是什么?
            // Object o = new Object();
            synchronized (o) {
                count++;
            }
        }
    }
    ```


#### 1.2 字节码实现  
1. 可以通过``` javac Foo.java ```命令生成.class文件，然后通过``` javap -v Foo.class ```将字节码反编译后显示在terminal中，或者使用idea的插件ASM Bytecode Viewer：  
2. 下面是t1()，t2()，t3()和t5()的字节码：  
    ```
    public static synchronized void t1();
    descriptor: ()V
    // JVM会解析方法的符号引用，然后根据flags去锁住锁定（类或者对象）
    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
    Code:
      stack=0, locals=0, args_size=0
         0: return
      LineNumberTable:
        line 12: 0



    public void t2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: ldc           #5                  // class juc/Foo
         2: dup
         3: astore_1
         4: monitorenter
         5: aload_1
         6: monitorexit
         7: goto          15
        10: astore_2
        11: aload_1
        12: monitorexit
        13: aload_2
        14: athrow
        15: return
      Exception table:
         from    to  target type
             5     7    10   any
            10    13    10   any
      LineNumberTable:
        line 15: 0
        line 16: 5
        line 17: 15
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 10
          locals = [ class juc/Foo, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4



    public synchronized void t3();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 20: 0



    public void t5();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=3, args_size=1
         // 偏移量: 指令
         // 将局部变量表中第一个局部变量的引用推到栈顶，对于非static方法，aload_0表示this
         0: aload_0
         1: getfield      #3                  // Field o:Ljava/lang/Object;
         // dup是复制栈顶元素，并压入栈顶
         4: dup
         // 0~5表示：将this对象入栈，使用duplicate指令复制栈顶元素并放入局部变量表位置1的地方，此时当前栈帧（方法执行的数据结构）的操作数栈（后进先出）中只有一个元素this
         5: astore_1
         // synchronized的具体实现由monitorenter和monitorexit指令完成
         6: monitorenter
         7: aload_0
         8: dup
         9: getfield      #4                  // Field count:I
        12: iconst_1
        13: iadd
        14: putfield      #4                  // Field count:I
        17: aload_1
        18: monitorexit
        19: goto          27
        // 以上是正常执行完方法的步骤，下面是编译器自动生成的异常处理步骤，必须保证不管正常执行完毕还是异常退出方法，都必须释放锁
        22: astore_2
        23: aload_1
        24: monitorexit
        25: aload_2
        26: athrow
        27: return
      Exception table:
         from    to  target type
             7    19    22   any
            22    25    22   any
      LineNumberTable:
        line 29: 0
        line 30: 7
        line 31: 17
        line 32: 27
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 22
          locals = [ class juc/Foo, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4

    ```


#### 1.3 JVM（ART）实现  
1. 在进入使用synchronized关键字的代码块时，会生成一条monitorenter指令，退出该代码块时生成一条monitorexit指令；  
2. 在ART虚拟机中，关于线程同步涉及到的类如下图所示，真正实现线程同步功能的是Monitor类（art/runtime/monitor.cc文件中定义）；  
    ![线程同步相关类](https://github.com/JQLewis/Notes/blob/main/1-pics/ART%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E7%B1%BB.png?raw=true)  
    - Monitor::monitor_lock_：类型为Mutex（art/runtime/base/Mutex.h），Mutex是ART虚拟机对Linux操作系统提供的同步机制的封装，后面介绍；  
    - Monitor::monitor_id_：类型为32位的无符号整型，每个Monitor对象都有一个id；  
    - Monitor::obj_：类型为GcRoot<mirror::Object>，每个Monitor对象都会关联一个Object对象；  
    - MonitorPool：Monitor和OS关联紧密（因为调用了系统提供的同步方法），所以每个Monitor很重要，由专门的MonitorPool管理其内存分配和回收；  
    - MonitorList：ART虚拟机用来管理虚拟机进程中分配的Monitor对象，可以看作一个list容器，这两个类是不参与线程同步的，了解一下即可；  
    - Object::monitor_：类型为32位无符号整型，这个monitor_对象指向的不是Monitor对象，而是一个LockWord对象；  
    - LockWord::value_：类型为32位无符号整型；
3. 既然Monitor对象是和Object对象关联的，为什么Object.monitor_指向的却不是真正的Monitor对象呢：  
    - Java层每个对象都可以作为同步锁，对应ART虚拟机层就是每个Object对象都包含一个可作为"同步锁"的成员变量；  
    - 但Object::monitor_却指向一个LockWord对象，是因为Monitor和OS关联紧密，属于重型资源，内存中有很多Object对象，但只有很少一部分被作为线程同步锁使用，所以不能每个Object对象都分配一个真正的Monitor对象；所以ART设计了LockWord类，代表Object对象中的"锁"；  
4. LockWord本身所需内存很小，只有一个成员变量``` uint32_t value_ ```，即Object::monitor_只有32位，而这个value_包含了多种信息。当synchronized修饰的代码块只有单个线程访问时，monitor_起到轻量级保护作用（后面解释），此时monitor_字段中保存的锁的类型是"Thin Lock"；当多个线程访问synchronized代码块时，monitor_字段中的锁类型标记位就需要膨胀成"Fat Lock"类型，而胖锁需要使用系统调用来确保多线程并发访问的正确性，这个膨胀的过程就是关联一个Monitor对象，通过Monitor对象实现多线程同步；LockWord的主要代码如下：  
    ```c
    class LockWord {
     public:
      enum SizeShiftsAndMasks : uint32_t {
        ...
        // 锁的类型：瘦、胖锁等
        kStateThinOrUnlocked = 0,
        kStateFat = 1,
        kStateHash = 2,
        kStateForwardingAddress = 3,
        ...
      };
    
      static LockWord FromThinLockId(uint32_t thread_id, uint32_t count, uint32_t gc_state) {
        ...
      }
      ...
    
      static LockWord FromDefault(uint32_t gc_state) {
        return LockWord(gc_state << kGCStateShift);
      }
    
      static LockWord Default() {
        // 默认创建一个状态为kUnlocked的瘦锁
        return LockWord();
      }
    
      // 锁的状态：表明是上锁还是没上锁
      enum LockState { 
        kUnlocked,    // No lock owners.
        kThinLocked,  // Single uncontended owner.
        kFatLocked,   // See associated monitor.
        ...
      };
      ...
    
     private:
      ...
    
      // The encoded value holding all the state.
      uint32_t value_;
    };
    }  // namespace art
    ```  
5. value_字段中不同bit保存不同的信息，具体看如下表格：  
    | 锁类型\bit范围 | 31-30 | 29-28 | 27-16 | 15-0 |  
    | ------ | ------ | ------ | ------ | ------ |  
    | kStateThinOrUnlocked | 00 | rb | Lock Count | Thread Id Owner |  
    | kStateFat | 01 | rb | Monitor Id | Monitor Id |  
    | kStateHash | 10 | rb | Hash Code | Hash Code |  
    | kStateForwardingAddress | 11 | Forwarding Address | Forwarding Address | Forwarding Address |  
    - 31-30位：表示锁的类型，目前只需要关注前两种即可；  
    - kStateThinOrUnlocked类型：29-28位包含一个Read Barrier；27-16位是一个计数器（lock count），最大4096；15-0位是持有当前锁的线程ID；  
    - kStateFat类型：27-0位是Monitor Id；
6. 前面提到，默认创建的类型是瘦锁，而瘦锁是可以通过一系列步骤转换为胖锁的，具体的操作在``` Monitor::Inflate ```函数中：  
    ```c
    void Monitor::Inflate(Thread* self, Thread* owner, ObjPtr<mirror::Object> obj, int32_t hash_code) {
      // 该函数的目标是将obj对象中的monitor_(LockWord类型)描述的瘦锁，转化为一个胖锁，其实就是将monitor_.value_中27-0位设置一个Monitor Id
      // 这样就可以在省内存的情况下，给obj对象关联了一个Monitor对象
      ...
      // 根据线程和obj参数，从Monitor池中获取一个Monitor对象
      Monitor* m = MonitorPool::CreateMonitor(self, owner, obj, hash_code);
      DCHECK(m != nullptr);
      // 真正的操作是调用Install函数
      if (m->Install(self)) {
        ...
        // 把这个monitor对象添加到Monitor List中进行管理
        Runtime::Current()->GetMonitorList()->Add(m);
        CHECK_EQ(obj->GetLockWord(true).GetState(), LockWord::kFatLocked);
      } else {
        MonitorPool::ReleaseMonitor(self, m);
      }
    }
    
    bool Monitor::Install(Thread* self) {
      MutexLock mu(self, monitor_lock_);  // Uncontended mutex acquisition as monitor isn't yet public.
      LockWord lw(GetObject()->GetLockWord(false));
      switch (lw.GetState()) {
        case LockWord::kThinLocked: {
          CHECK_EQ(owner_->GetThreadId(), lw.ThinLockOwner());
          // 如果当前是瘦锁，则需要更新该锁被上锁的次数，前面提到单线程多次上锁的情况，在转化为胖锁时，需要保留原瘦锁的信息，以防后续减肥时需要还原瘦锁及其信息
          lock_count_ = lw.ThinLockCount();
          break;
        }
        ... 
        // 其他状态要么是报错，要么不处理
      }
      // 构建胖锁，this表示的是Monitor，所以胖锁创建时会关联一个Monitor对象
      LockWord fat(this, lw.GCState());
      // 将新建的胖锁，更新到obj对象的monitor_成员变量中，CasLockWord()内部最终通过AtomicInteger对象的CompareAndSet()函数，
      // 将当前obj_对象中monitor_.value_更换为新的胖锁的value_，从始至终更换的都是32位无符号整型value_的值
      bool success = GetObject()->CasLockWord(lw, fat, CASMode::kWeak, std::memory_order_release);
      ...
      return success;
    }  
    ```  
    > CAS操作：Compare And Swap，是一种"无锁"算法，不管Java层还是C层，多线程并发访问同一变量，要么用锁把这个变量锁起来，要么使用CAS算法，最终由汇编指令保证更新内存操作的原子性；ART虚拟机中使用AtomicXXX来实现原子操作；  
7. 当然也有胖锁转化为瘦锁的操作，在Monitor::Deflate()函数中：  
    ```c
    bool Monitor::Deflate(Thread* self, ObjPtr<mirror::Object> obj) {
      LockWord lw(obj->GetLockWord(false));
      if (lw.GetState() == LockWord::kFatLocked) {
        // 内部是根据 Monitor Id 通过MonitorPool::MonitorFromMonitorId()获取到obj对象关联的胖锁对象
        Monitor* monitor = lw.FatLockMonitor();
        MutexLock mu(self, monitor->monitor_lock_);
        // 如果发现还有其他线程等待获取该对象锁，则直接return，不进行瘦身
        if (monitor->num_waiters_ > 0) {
          return false;
        }
        Thread* owner = monitor->owner_;
        if (owner != nullptr) {
          if (monitor->HasHashCode()) {
            return false;
          }
          if (static_cast<uint32_t>(monitor->lock_count_) > LockWord::kThinLockMaxCount) {
            return false;
          }
          // 创建瘦锁
          LockWord new_lw = LockWord::FromThinLockId(owner->GetThreadId(),
                                                     monitor->lock_count_,
                                                     lw.GCState());
          // 更新obj的monitor_成员变量
          obj->SetLockWord(new_lw, false);
        }
        // 因为减肥成瘦锁，原来的obj对象不再需要Monitor对象了，所以解绑
        monitor->obj_ = GcRoot<mirror::Object>(nullptr);
      }
      return true;
    }
    ```  
    > 但Deflate()函数并没有被调用到，是因为 胖->瘦 涉及到内存回收，ART放到了GC部分处理了，此处只需要了解一下就行；  
8. 有了以上基础，看一下Java对synchronized的处理，是在进入synchronized修饰的代码块之前，执行monitorenter指令，退出代码块时执行monitorexit指令。但ART运行时有2种方法：解释执行模式，机器码执行模式（AOT模式），不同模式下执行指令的方式不一样。  
    > ART运行时模式：默认是机器码执行模式，可以通过-Xint指定。【解释执行模式】是取出dex code，由解释器逐条执行；【机器码执行模式】是在安装时，把dex优化成机器码，运行时直接执行机器码，即AOT；  
9. **解释执行模式**：Android 11 的代码执行入口会走到MONITOR_ENTER()方法（runtime/interpreter/interpreter_switch_impl-inl.h文件中），接着走到静态方法DoMonitorEnter()中（在runtime/interpreter/interpreter_common.h文件）：  
    ```c
    template <bool kMonitorCounting>
    static inline void DoMonitorEnter(Thread* self, ShadowFrame* frame, ObjPtr<mirror::Object> ref)
        NO_THREAD_SAFETY_ANALYSIS
        REQUIRES(!Roles::uninterruptible_) {
      ...
      StackHandleScope<1> hs(self);
      Handle<mirror::Object> h_ref(hs.NewHandle(ref));
      // 这里拿到准备被锁住的obj对象并执行Object::MonitorEnter()函数
      h_ref->MonitorEnter(self);
      ...
      if (kMonitorCounting && frame->GetMethod()->MustCountLocks()) {
        frame->GetLockCountData().AddMonitor(self, h_ref.Get());
      }
    }
    ```  
    - 接着进入当前锁对象obj的Object::MonitorEnter()函数（位于runtime/mirror/object-inl.h文件中）：  
    ```c
    inline ObjPtr<mirror::Object> Object::MonitorEnter(Thread* self) {
      return Monitor::MonitorEnter(self, this, /*trylock=*/false);
    }
    ```  
    - 可以看到，传入了想要争用锁的线程对象，并调用Monitor::MonitorEnter()函数，进入查看（在runtime/monitor.cc文件中）：  
    ```c
    ObjPtr<mirror::Object> Monitor::MonitorEnter(Thread* self,
                                                 ObjPtr<mirror::Object> obj,
                                                 bool trylock) {
      ...
      // 这个参数很重要，是ART优化时使用到的参数
      size_t contention_count = 0;
      StackHandleScope<1> hs(self);
      Handle<mirror::Object> h_obj(hs.NewHandle(obj));
      // 循环！！！
      while (true) {
        // 获取obj的monitor_（32位无符号整型），并赋值到lock_word.value_中
        LockWord lock_word = h_obj->GetLockWord(false);
        switch (lock_word.GetState()) {
          case LockWord::kUnlocked: {
            // 如果当前obj对象处于未上锁状态，则创建瘦锁并更新到obj.monitor_中
            LockWord thin_locked(LockWord::FromThinLockId(thread_id, 0, lock_word.GCState()));
            // 执行CasLockWord()函数，内部使用C++ AtomicInteger保证原子操作，将瘦锁更新到当前obj.monitor_中
            if (h_obj->CasLockWord(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) {
              AtraceMonitorLock(self, h_obj.Get(), /* is_wait= */ false);
              return h_obj.Get();  // Success!
            }
            continue;  // Go again.
          }
          case LockWord::kThinLocked: {
            // 如果当前obj对象已经上了瘦锁，说明有一个线程在使用这个锁，先拿到这个线程id
            uint32_t owner_thread_id = lock_word.ThinLockOwner();
            // 如果发现准备争用对象锁的线程就是当前线程，即同一个线程多次获取obj对象锁
            if (owner_thread_id == thread_id) {
              // 持有该锁的线程再次获取锁，只需要lock count位加一即可
              uint32_t new_count = lock_word.ThinLockCount() + 1;
              if (LIKELY(new_count <= LockWord::kThinLockMaxCount)) {
                // lock count 有个默认最大值4096，因为使用27-16位来保存的这个字段
                // 创建新的瘦锁，并将lock count 加一即可
                LockWord thin_locked(LockWord::FromThinLockId(thread_id,
                                                              new_count,
                                                              lock_word.GCState()));
                if (!kUseReadBarrier) {
                  h_obj->SetLockWord(thin_locked, /* as_volatile= */ false);
                  AtraceMonitorLock(self, h_obj.Get(), /* is_wait= */ false);
                  return h_obj.Get();  // Success!
                } else {
                  if (h_obj->CasLockWord(lock_word,
                                         thin_locked,
                                         CASMode::kWeak,
                                         std::memory_order_relaxed)) {
                    AtraceMonitorLock(self, h_obj.Get(), /* is_wait= */ false);
                    return h_obj.Get();  // Success!
                  }
                }
                continue;  // Go again.
              } else {
                // 如果一个线程获取锁的次数大于4096，则需要膨胀了
                InflateThinLocked(self, h_obj, lock_word, 0);
              }
            } else {
              // 说明是第二个线程来争用这个obj对象的锁，这时候也需要膨胀了
              ...
              contention_count++;
              ...
              // 这里的逻辑和最外层的while循环配合使用，这是ART做出的优化操作：
              if (contention_count <= runtime->GetMaxSpinsBeforeThinLockInflation()) {
                // 1. 如果循环的次数contention_count<50（即runtime->GetMaxSpinsBeforeThinLockInflation()最终获取的是Opt::MaxSpinsBeforeThinLockInflation的值，默认50次），
                //    则通过sched_yield系统调用，当前调用线程B（新的竞争锁的线程）会让出执行资格，操作系统将在后续某个时间恢复该新竞争线程B的执行，这就存在一个时间间隔；
                // 2. 在这个时间间隔中，有可能正在占用锁的线程A释放了锁，那就不用使用Monitor这个重型资源了，达到优化的目的，但循环的次数上限为50次，因为多核CPU可能会导致这个时间间隔很短，
                //    接近于0，会导致新竞争线程B不必要的一直等待；
                // 3. 表现：新的竞争锁的线程等待一会，不继续执行；
                sched_yield();
              } else {
                contention_count = 0;
                // 3. 所以如果循环了50次后新竞争线程B还是拿不到锁，那就只能将锁升级为胖锁，使用Monitor实现同步了。
                InflateThinLocked(self, h_obj, lock_word, 0);
              }
            }
            continue;  // Start from the beginning.
          }
          case LockWord::kFatLocked: {
            // 如果是已经是胖锁了，其他线程来争用这个锁，则使用monitor->lock()函数获取锁，实现线程间同步
            std::atomic_thread_fence(std::memory_order_acquire);
            Monitor* mon = lock_word.FatLockMonitor();
            if (trylock) {
              return mon->TryLock(self) ? h_obj.Get() : nullptr;
            } else {
              // 如果锁已经被占用，则新的竞争线程B会在此处等待，直到lock()函数返回，lock()内部使用操作系统的futex实现线程间同步
              mon->Lock(self);
              return h_obj.Get();  // Success!
            }
          }
          ...
          }
        }
      }
    }
    ```  
    总结如下：  
    ![MonitorEnter实现](https://github.com/JQLewis/Notes/blob/main/1-pics/MonitorEnter%E5%AE%9E%E7%8E%B0.png?raw=true)  
    - 了解了ART做的一些优化，接着看瘦锁膨胀的流程，在Monitor::InflateThinLocked(art/runtime/monitor.cc文件中)：  
    ```c
    void Monitor::InflateThinLocked(Thread* self, Handle<mirror::Object> obj, LockWord lock_word,
                                    uint32_t hash_code) {
      uint32_t owner_thread_id = lock_word.ThinLockOwner();
      if (owner_thread_id == self->GetThreadId()) {
        // 如果是同一个线程，直接调用Inflate()函数，这种情况一般是同一个线程多次获取锁并且获取次数超过4096，不能不转化为胖锁
        Inflate(self, self, obj.Get(), hash_code);
      } else {
        // 如果是多个线程竞争同一个对象锁，就需要膨胀了，过程和把大象装冰箱总共分3步一样
        ThreadList* thread_list = Runtime::Current()->GetThreadList();
        self->SetMonitorEnterObject(obj.Get());
        bool timed_out;
        Thread* owner;
        {
          ScopedThreadSuspension sts(self, kWaitingForLockInflation);
          // 1. 先将当前拥有锁的线程暂停，只是暂停当前线程的运行，并不是让线程放弃CPU的执行
          owner = thread_list->SuspendThreadByThreadId(owner_thread_id,
                                                       SuspendReason::kInternal,
                                                       &timed_out);
        }
        if (owner != nullptr) {
          lock_word = obj->GetLockWord(true);
          if (lock_word.GetState() == LockWord::kThinLocked &&
              lock_word.ThinLockOwner() == owner_thread_id) {
            // 2. 然后将瘦锁转化为胖锁
            Inflate(self, owner, obj.Get(), hash_code);
          }
          // 3. 再把线程恢复运行
          bool resumed = thread_list->Resume(owner, SuspendReason::kInternal);
        }
        self->SetMonitorEnterObject(nullptr);
      }
    }
    ```  
    - 所以，锁膨胀的过程是需要将当前持有锁的线程暂停运行的；  
    - Monitor::MonitorExit()函数的过程其实涉及到 胖->瘦 的过程，比较简单，也是判断锁状态，如果是瘦锁，那就将锁的lockcount--，但如果是胖锁，直接执行Monitor::Unlock()函数，而不是执行Monitor::Deflate()函数，因为涉及到锁的内存回收，所以放在了GC部分，就不展开讨论了；  
10. 总结：  
Java层的synchronized字段的实现，是由编译器编译时，在synchronized代码块开始时添加并执行monitorenter指令，在离开代码块时添加并执行monitorexit指令（至于这两条指令的执行入口到底在哪，后面介绍），而这两条指令的JVM实现主要在art/runtime/monitor.cc中，monitor是使用ART封装的Mutex（互斥锁）实现的，而Mutex又是使用了futex系统调用或pthread中pthread_mutex_t相关函数（具体使用哪种由ART的ART_USE_FUTEXES宏控制）；  


#### 1.4 操作系统层实现  
其实Mutex（art/runtime/base/mutex.cc文件）是ART虚拟机封装的一个互斥锁，最终使用的是Android操作系统（Linux）的同步机制【futex系统调用】或【pthread中pthread_mutex_t的相关方法】实现的，先简单介绍一下Mutex：  
1. 在art/runtime/base/mutex.h文件头部中定义了宏ART_USE_FUTEXES：  
    ```c
    #if defined(__linux__)
    #define ART_USE_FUTEXES 1
    #else
    #define ART_USE_FUTEXES 0
    #endif
    ```  
    Android系统是基于Linux的，所以默认使用futex机制实现线程同步；  
2. 介绍futex机制之前先看一下Mutex::ExclusiveLock()的实现，即使用Mutex上锁的操作：  
    ```c
    void Mutex::ExclusiveLock(Thread* self) {
      ...
      if (!recursive_ || !IsExclusiveHeld(self)) {
    // 从这开始！
    #if ART_USE_FUTEXES
        bool done = false;
        do {
          int32_t cur_state = state_and_contenders_.load(std::memory_order_relaxed);
          if (LIKELY((cur_state & kHeldMask) == 0) /* lock not held */) {
            // 判断如果锁没有被任何线程持有，则更新state_and_contenders的低位值，标记此时锁被持有了
            // state_and_contenders是AtomicInteger类型（32位有符号整型）的对象，低位0表示没有被持有，低位1表示被持有
            done = state_and_contenders_.CompareAndSetWeakAcquire(cur_state, cur_state | kHeldMask);
          } else {
            // 此处代表争用锁失败，则需要将线程挂起
            ScopedContentionRecorder scr(this, SafeGetTid(self), GetExclusiveOwnerTid());
            // 1. 记录竞争线程的个数+1
            increment_contenders();
            cur_state += kContenderIncrement;
            // 2. 在执行futex系统调用前，当前线程需要先检查标记位as_struct类型（在art/runtime/thread.h文件中），优先执行其他事情（指的是as_struct里标记的事情）
            if (UNLIKELY(should_respond_to_empty_checkpoint_request_)) {
              self->CheckEmptyCheckpointFromMutex();
            }
            // 3. 然后执行futex()函数，此处会让新的竞争线程进入睡眠等待
            if (futex(state_and_contenders_.Address(), FUTEX_WAIT_PRIVATE, cur_state,
                      nullptr, nullptr, 0) != 0) {
              if ((errno != EAGAIN) && (errno != EINTR)) {
                PLOG(FATAL) << "futex wait failed for " << name_;
              }
            }
            decrement_contenders();
          }
        } while (!done);
        ...
    #else
        ...
    #endif
        exclusive_owner_.store(SafeGetTid(self), std::memory_order_relaxed);
        RegisterAsLocked(self);
      }
      recursion_count_++;
      ...
    }
    ```  
    > ART虚拟机Check Point机制：Java线程执行指令时，会时常检查标记位as_struct，如果有变化，就需要让线程先去执行标记位中标记的一些事情，这些事情包括GC等等，这里表现出来的就是程序卡顿、无响应；  
    - art::futex()函数使用系统调用，即syscall()函数，指令是SYS_futex（定义在art/runtime/mutex-inl.h文件头部）；  
    ```c
    #if ART_USE_FUTEXES
    static inline int futex(volatile int *uaddr, int op, int val, const struct timespec *timeout,
                            volatile int *uaddr2, int val3) {
      return syscall(SYS_futex, uaddr, op, val, timeout, uaddr2, val3);
    }
    #endif  // ART_USE_FUTEXES
    ```
3. Linux操作系统的【系统调用futex】：  
    - Futex：Fast Userspace Mutexes的缩写，快速用户空间互斥体；  
    - 传统的进程同步机制semaphores, msgqueues, sockets等，都是对内核空间中的一个内核对象（这个内核对象提供了原子操作）进行操作，这个内核对象对于所有要同步的进程都是可见的，当进程间需要同步的时候，都需要通过系统调用在内核空间完成一些操作，比如操作上述的内核对象，这种系统调用是很耗费资源的；  
    - 但发现，很多时候，很多同步是没有竞争的，就是说一个进程进入互斥区，到退出互斥区，往往没有其他进程要抢着进入互斥区，这种情况下进程仍然需要通过系统调用，操作内核空间的对象，比较浪费，所以为了降低这种消耗，Futex机制诞生；  
    - 其实说白了，Futex机制目的就是减少进程同步时对内核空间的不必要的访问，从而减少资源消耗，Futex是一种用户态和内核态混合的同步机制；  
    - Futex机制是通过mmap分配一段共享内存，futex变量保存在这段共享内存中，当进程准备进入/退出互斥区时，先去共享内存中查看futex变量的值，而不是通过系统调用直接操作内核空间的对象。如果没竞争，则只需要修改共享内存中的futex变量，如果futex变量的值表示有进程间的竞争，则还是得通过系统调用去完成相应的操作；  
    - 对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量；  
    - 所以Futex在程序low-contention的时候能获得比传统同步机制更好的性能；  
    - 【维基百科上这么描述】：Futex 由一块能够被多个进程共享的内存空间（一个对齐后的整型变量）组成；这个整型变量的值能够通过汇编语言调用CPU提供的原子操作指令来增加或减少，并且一个进程可以等待直到那个值变成正数。Futex 的操作几乎全部在用户空间完成；只有当操作结果不一致从而需要仲裁时，才需要进入操作系统内核空间执行。这种机制允许使用 futex 的锁定原语有非常高的执行效率：由于绝大多数的操作并不需要在多个进程之间进行仲裁，所以绝大多数操作都可以在应用程序空间执行，而不需要使用（相对高代价的）内核系统调用；  



#### 1.5 CPU层实现
1. 在前面2.3.10中留了个问题：monitorenter和monitoerexit这两条指令的执行入口到底在哪？不同CPU架构，执行不同的汇编代码，下面以ARM架构简单描述一下，有兴趣也可以对比x86的实现，更容易理解；  
2. 可以查看生成汇编语言程序的InstructionCodeGeneratorARMVIXL::VisitMonitorOperation()函数（定义在art/compiler/optimizing/code_generator_arm_vixl.cc文件中）：  
    ```c
    void InstructionCodeGeneratorARMVIXL::VisitMonitorOperation(HMonitorOperation* instruction) {
      // 1. 如果是monitorenter，则传入kQuickLockObject，monitorexit的话传入kQuickUnlockObject
      // 2. ARM架构下，kQuickLockObject指向汇编函数art_quick_lock_object（定义在art/runtime/entrypoints/quick/quick_default_externs.h文件中），
      //    即art_quick_lock_object函数由汇编代码实现
      codegen_->InvokeRuntime(instruction->IsEnter() ? kQuickLockObject : kQuickUnlockObject,
                              instruction,
                              instruction->GetDexPc());
      if (instruction->IsEnter()) {
        CheckEntrypointTypes<kQuickLockObject, void, mirror::Object*>();
      } else {
        CheckEntrypointTypes<kQuickUnlockObject, void, mirror::Object*>();
      }
      codegen_->MaybeGenerateMarkingRegisterCheck(/* code= */ 18);
    }
    ```
    > vixl 是安卓系统使用的针对ARMv8 架构的动态代码生成工具，x86架构对应的汇编程序在code_generator_x86.cc文件中；
3. 由于篇幅过长，下面只介绍lock过程的实现，继续找汇编代码，在art/runtime/arch/arm/quick_entrypoints_arm.S文件的art_quick_lock_object方法，.S文件是汇编程序文件格式：  
    ```c
    ENTRY art_quick_lock_object
        ldr    r1, [rSELF, #THREAD_ID_OFFSET]
        // cbz指令:把r0的值和0比较，如果相等，则执行后面的.Lslow_lock指令
        cbz    r0, .Lslow_lock
    .Lretry_lock:
        ...
    .Lnot_unlocked:  @ r2: original lock word, r1: thread_id, r3: r2 ^ r1
        ...
    .Llock_strex_fail:
        b      .Lretry_lock               @ retry
    END art_quick_lock_object
    
    ENTRY art_quick_lock_object_no_inline
        ...
    .Lslow_lock:
        SETUP_SAVE_REFS_ONLY_FRAME r1     @ save callee saves in case we block
        mov    r1, rSELF                  @ pass Thread::Current
        // 注意这里！bl指令：跳转到artLockObjectFromCode函数
        bl     artLockObjectFromCode      @ (Object* obj, Thread*)
        RESTORE_SAVE_REFS_ONLY_FRAME
        REFRESH_MARKING_REGISTER
        RETURN_IF_RESULT_IS_ZERO
        DELIVER_PENDING_EXCEPTION
    END art_quick_lock_object_no_inline
    ```  
    - 当跳转到.Lslow_lock后，会执行artLockObjectFromCode函数，该函数在art/runtime/entrypoints/quick/quick_lock_entrypoints.cc文件中：  
    ```c
    extern "C" int artLockObjectFromCode(mirror::Object* obj, Thread* self)
        NO_THREAD_SAFETY_ANALYSIS
        REQUIRES(!Roles::uninterruptible_)
        REQUIRES_SHARED(Locks::mutator_lock_) /* EXCLUSIVE_LOCK_FUNCTION(Monitor::monitor_lock_) */ {
      ScopedQuickEntrypointChecks sqec(self);
      if (UNLIKELY(obj == nullptr)) {
        ...
      } else {
        // 就是这，终于连起来了...
        ObjPtr<mirror::Object> object = obj->MonitorEnter(self);  // May block
        ...
        return 0;
      }
    }
    ```
    > x86架构的汇编代码中，使用lock cmpxchg命令：（LOCK_IF_MP）-> lock cmpxchg ，即如果是多核CPU，则在执行CAS时加上操作系统的lock指令；其中上锁操作锁的是总线，多个CPU访问同一块内存是通过总线访问；单核就不加lock命令了；意思是"lock"命令保证"cmpxchg"操作是一个原子性操作，不允许被其他CPU打断cmpxchg操作（即：CAS写一块内存时，不允许其他CPU访问这块内存）


#### 1.6 总结
- Java代码添加synchronized修饰符后，编译器编译成字节码时，会在进入同步代码块前添加monitorenter指令，退出代码块时添加monitorexit指令；  
- monitorenter指令对应的汇编代码被CPU执行时（当然不是直接执行汇编指令，会和CPU指令集有对应），执行了artLockObjectFromCode()函数；  
- artLockObjectFromCode()函数调用了obj->MonitorEnter(self)函数；  
- MonitorEnter()函数根据判断，如果同一个线程获取锁，则更新lock count；如果多线程争用锁，则看情况，严重的话使用ART提供的Mutex互斥锁；  
- 而Mutex的实现是使用了系统调用futex()函数；  



================================================================



### 2. volatile

#### 2.1 volatile介绍  
1. volatile是JVM提供的一种最轻量级的同步机制；  
2. Java内存模型的3大特性：可见性、有序性和原子性，volatile用于实现Java内存模型中的可见性和有序性，但不保证原子性；  


#### 2.2 可见性  
1. 定义为volatile修饰的变量，在线程对其进行写入操作时不会把值缓存在工作内存中，而是直接把修改后的值刷新回写到主内存；  
2. 而当处理器监控到其他线程中该变量在主内存中的内存地址发生变化时，会让这些线程在使用该变量前，重新到主内存中拷贝这个变量的最新值到工作内存中，而不是继续使用工作内存中旧的缓存；  


#### 2.3 有序性  
1. 指被volatile修饰的数据，禁止JVM指令重排序优化，这种指令重排优化只保证最终结果一致，但不保证中间指令的执行顺序和代码顺序一致，优化的一条规则是，没有数据依赖关系，例如：  
    ```java
    // 1. 无依赖关系
    int i = 0;
    boolean b = false;
    i = 1;
    b = true;
    
    // 2. 有依赖关系
    int a = 1;
    int b = 2;
    int c = a * b;
    ```
2. 从DCL单例模式理解有序性：  
    ```java
    public class Foo {
        private volatile static Foo foo;
        private Foo() { }
    
        public static Foo getFoo() {
            // (1)
            if (foo == null) {
                // (2)
                synchronized (Foo.class) {
                    // (3)
                    if (foo == null) {
                        // (4)
                        foo = new Foo();
                    }
                }
            }
            return foo;
        }
    }
    ```  
    - 多线程获取单例时，如果foo对象没有被volatile修饰，则有可能造成获取单例失败（foo对象非法），为什么？  
    - 在(4)步骤中，虽然Java代码是一行，去初始化一个foo对象，但运行时会分解成3步：1）在堆中为Foo对象开辟内存空间；2）调用Foo类的构造函数，初始化赋值成员变量；3）调用"="，将引用foo指向分配的堆内存；此时foo就非空了；  
    - 由于JVM执行重排序优化，所以无法保证 2）和 3）的先后顺序；  
    - 如果已经获得锁的线程A正在初始化foo对象且走到 3），但 3）在 2）前面执行了（即以 1）-> 3）-> 2）的顺序初始化foo对象），此时foo引用就不为null了，这时候如果线程B想要获取单例，在(1)发现foo!=null成立，则会直接返回foo对象给线程B，但此时的foo对象是非法的、不完整的；  
    - 这就是为什么DCL必须加volatile的原因；  


#### 2.4 volatile的实现
1. volatile是通过给代码增加内存屏障指令实现可见性和有序性的；  
2. 在Java编译器生成JVM指令时，插入特定的内存屏障指令，通过这些内存屏障指令来禁止特定的指令重排序；  
3. volatile变量和普通变量的区别：  
    1）读操作没区别；  
    2）写操作有区别：volatile会影响一点性能，因为会在代码中插入一些内存屏障指令来保证处理器不发生乱序执行；  
4. Java层想要读取或设置某个对象的成员变量，最终会调用到C层Object对象的GetField()函数和SetField()函数；  



================================================================



### 3. Java锁
Java提供了种类丰富的锁，按照特性的不同，可以按以下宏观概念理解：  
    - 乐观锁和悲观锁；  
    - 自旋锁；  
    - 无锁、偏向锁、轻量级锁、重量级锁；  
    - 公平锁和非公平锁；  
    - 可重入锁和非可重入锁；  
    - 独享锁（排他锁）和共享锁；  
    ![Java锁的种类](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB.png?raw=true)  

#### 3.1 乐观锁VS悲观锁
1. 悲观锁：  
对于同一数据的多线程并发操作，悲观锁认为，自己在使用数据的时候一定有其他线程来修改数据，因此get数据的时候先加锁，确保数据不会被其他线程修改，Java中的synchronized关键字和Lock的实现类都是悲观锁；  
2. 乐观锁：  
认为自己在使用数据时不会被别的线程修改，所以不会添加锁，只是在更新数据的时候去判断之前有没有其他线程更新了这个数据。如果没有被更新，当前线程write成功；如果被更新，当前线程根据不同的实现类，执行不同的操作（例如报错或自动重试）。乐观锁在Java中是通过使用无锁编程实现的，采用CAS算法，Java原子类中的递增操作就是通过CAS自旋实现的；  
3. 使用场景：  
    - 悲观锁适合write场景，synchronized，ReentrantLock，都是显式的加锁后再操作同步资源或代码块；  
    - 乐观锁适合read场景，AtomicInteger.incrementAndGet()，Java层不锁定，直接操作资源；  
4. 乐观锁使用CAS算法实现多线程同步：  
CAS（Compare and Swap），无锁算法，在不使用锁，并且线程没有被阻塞的情况下实现多线程之间数据同步。CAS算法涉及到三个操作数：需要读写的内存值V；进行比较的的值A；待写入的新值B；  
当且仅当V==A，通过原子方式让V=B（"比较+更新"整体是一个原子操作，最终是由操作系统的lock命令保证的），否则由一个do()while{}循环，继续从头执行上述三个步骤，自旋次数也是有上线的（默认10次，看具体的操作系统，可以通过JVM参数修改）；  
java.utils.concurrent包中的原子类就是通过CAS实现乐观锁，例如AtomicInteger：  
    ```java  
    public class AtomicInteger extends Number implements java.io.Serializable {
        private static final long serialVersionUID = 6214790243416807050L;
        // 获取并操作内存的数据
        private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();
        // value在AtomicInteger中的偏移量
        private static final long VALUE;
    
        static {
            try {
                VALUE = U.objectFieldOffset
                    (AtomicInteger.class.getDeclaredField("value"));
            } catch (ReflectiveOperationException e) {
                throw new Error(e);
            }
        }
        // 真正的int值，volatile修饰，保证线程之间是可见的
        private volatile int value;
        
        ......
        
        public final int incrementAndGet() {
            // 最终调用Unsafe.getAndAddInt()实现自增
            return U.getAndAddInt(this, VALUE, 1);
        }
    }
    
    // sun.misc.Unsafe.getAndAddInt()
    public final int getAndAddInt(Object o, long offset, int delta) {
        int var5;
        // 该方法循环获取给定对象o中的偏移量的值var5，然后判断内存中的值是否等于var5
        // 如果相等，则将内存值设置为新值；否则继续自旋（即不切换线程，就在当前现在通过while循环不断判断，直到某个条件成立退出循环），当然自旋也有限制
        do {
            var5 = this.getIntVolatile(o, offset);
        } while(!this.compareAndSwapInt(o, offset, var5, var5 + delta));
        return var5;
    }
    ```  
5. CAS高效，因为自旋减少切换线程所需的开销，但存在3个问题：  
    - ABA的问题：CAS需要在操作值之前检查内存值是否发生变化，没有变化才更新内存值；但如果内存值由A->B->A最终变回A，但其实内存值是变化过的，这种情况不能被忽略，所以在变量前添加版本号即可；  
    - while循环时间长开销大：如果长时间while，会一直自旋，一直占用CPU资源，开销也很大；  
    - 只能保证一个共享变量的原子操作：无法保证同时对多个共享变量的原子性操作，所以JDK1.5开始提供了AtomicReference，把多个变量放到一个对象来保证执行CAS操作时的原子性；  


#### 3.2 自旋锁
1. 阻塞或唤醒一个Java线程需要操作系统切换CPU状态，这种状态切换需要耗费处理器时间。如果同步代码内容很简单，状态转换消耗的时间可能比执行代码的还长，为了这种情况切换线程（线程挂起、恢复现场，状态同步），得不偿失；  
2. 如果机器有多个处理器，能让2个或以上线程同时并行执行，则可以让后来的请求锁的thread不放弃CPU的执行时间，而是通过自旋的方式"稍稍等待一下"，看看当前持有锁的线程是否很快就释放锁。如果自旋完成后，前面线程释放了锁，则当前线程可以直接获取锁并且执行同步代码，而不必走"阻塞->唤醒"这样耗时耗资源的步骤，这就是自旋锁；  
3. 说白了，自旋锁可以简单理解为：如果发现锁被其他线程拿着，在当前线程，一定条件的while循环，而不是阻塞当前线程：  
    ![自旋锁](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E8%87%AA%E6%97%8B%E9%94%81.png?raw=true)  
4. 实现原理也是CAS，例如AtomicInteger.getAndAddInt()：
    ```java
    public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        // compareAndSwapInt()调用的是Unsafe中对应的方法
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }
    ```
5. 缺点：  
不能代替线程阻塞，自旋是可以减少线程切换的开销，但会占用CPU执行时间。如果锁被占用的时间很少，那自旋锁效果很好，反之，也会浪费CPU资源。所以自旋的while是有限制的，超过自旋次数就挂起线程；  



#### 3.3 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
1. 指的是锁的四种状态；  
2. 无锁：  
无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。即上面CAS原理及实现，例如AtomicInteger；  
3. 偏向锁：  
是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价（如果一段synchronized代码，只有一个线程在执行，每次执行都CAS操作，该操作中包含"获取锁->释放锁"，没有必要）。只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。释放后锁的状态恢复到无锁或轻量级锁；
4. 轻量级锁：  
是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。  
5. 重量级锁：  
若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。  


#### 3.4 公平锁 VS 非公平锁
1. 公平锁：  
公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。
2. 非公平锁：  
非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。
3. Java中具体的实现，ReentrantLock可以选择创建哪种锁：  
    ```java
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    ```  
    可从下图中看出，唯一区别就是，公平锁多了判断hasQueuedPredecessors()，表示当前线程是否位于同步队列的第一个，如果是则返回true
    ![公平锁](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E5%85%AC%E5%B9%B3%E9%94%81.png?raw=true)



#### 3.5 可重入锁 VS 非可重入锁
1. 以下代码会造成死锁：  
    ```java
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
    ```
2. ReentrantLock和synchronized都是可重入锁，重入状态内部通过一个被volatile修饰的int类型的变量state来描述，仅对于当前线程来说，每次尝试获取锁成功时，state++，对应释放锁的state--：  
    ![可重入锁](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png?raw=true)  



#### 3.6 独享锁 VS 共享锁
- 是对可重入锁对进一步优化，因为单纯的可重入锁ReentrantLock，state状态记录的是包括读和写，即"读，写"都需要加锁，效率还是比较低，所以引入"独享锁（排他锁）和共享锁"；  
- 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。synchronized和Lock的实现类都是独享锁；  
- 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。  
- 具体的实现类是java.util.concurrent.locks.ReentrantReadWriteLock：  
    ![独享锁](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E7%8B%AC%E4%BA%AB%E9%94%81%E5%85%B1%E4%BA%AB%E9%94%81.png?raw=true)  
- 内部有两把锁ReadLock和WriteLock分别标记读和写，都是Sync的子类，Sync是AQS(AbstractQueuedSynchronizer)的子类，state就保存在AQS中；读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升；
- 其原理简单概括：将32位int类型的变量state分为【高16位】和【低16位】，分别存储读锁个数和写锁个数：  
    ```java
    // 写锁代码
    protected final boolean tryAcquire(int acquires) {
    	Thread current = Thread.currentThread();
    	int c = getState(); // 取到当前锁的个数
    	int w = exclusiveCount(c); // 取写锁的个数w
    	if (c != 0) { // 如果已经有线程持有了锁(c!=0)
        // (Note: if c != 0 and w == 0 then shared count != 0)
    		if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败
    			return false;
    		if (w + exclusiveCount(acquires) > MAX_COUNT)    // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。
          throw new Error("Maximum lock count exceeded");
    		// Reentrant acquire
        setState(c + acquires);
        return true;
      }
      if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。
    		return false;
    	setExclusiveOwnerThread(current); // 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者
    	return true;
    }
    
    // 读锁代码
    protected final int tryAcquireShared(int unused) {
        Thread current = Thread.currentThread();
        int c = getState();
        if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
            return -1;                                   // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态
        int r = sharedCount(c);
        if (!readerShouldBlock() &&
            r < MAX_COUNT &&
            compareAndSetState(c, c + SHARED_UNIT)) {
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }
            return 1;
        }
        return fullTryAcquireShared(current);
    }
    ```
- 总结：多线程之间，读读共享，读写、写读、写写都是互斥的；


#### 3.7 Unsafe类  
看过Java锁的代码后发现，所有的锁最终都会调用sun.misc.Unsafe的API来实现，接着有必要继续深入研究一下黑科技Unsafe；  
1. 主要功能如下：  
    ![Unsafe](https://github.com/JQLewis/Notes/blob/main/1-pics/Java%E9%AD%94%E6%B3%95%E7%B1%BBUnsafe.png?raw=true)  
2. Unsafe.java是单例，提供静态方法getUnsafe()获取Unsafe对象，当且仅当调用getUnsafe()的类为BootstrapClassLoader加载时才合法，否则抛出SecurityException异常：  
    ```java
    public final class Unsafe {
      // 单例对象
      private static final Unsafe theUnsafe;
    
      private Unsafe() {
      }
      @CallerSensitive
      public static Unsafe getUnsafe() {
        Class var0 = Reflection.getCallerClass();
        // 仅在引导类加载器`BootstrapClassLoader`加载时才合法
        if(!VM.isSystemDomainLoader(var0.getClassLoader())) {    
          throw new SecurityException("Unsafe");
        } else {
          return theUnsafe;
        }
      }
    }
    ```  
3. 如何获取Unsafe单例对象，然后构造对象？  
    - 通过反射获取Unsafe对象，可以参考Gson的实现：  
        ```java
        // 反序列化时Gson首先尝试通过bean类的默认构造方法方法创建bean对象，如果没找到默认构造方法，则最后尝试使用Unsafe直接绕过bean的构造方法直接创建bean对象
        private <T> ObjectConstructor<T> newUnsafeAllocator(
            final Type type, final Class<? super T> rawType) {
          return new ObjectConstructor<T>() {
            private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
            @SuppressWarnings("unchecked")
            @Override public T construct() {
              try {
                Object newInstance = unsafeAllocator.newInstance(rawType);
                return (T) newInstance;
              } catch (Exception e) {
                throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
                    + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
              }
            }
          };
        }

        public static UnsafeAllocator create() {
            try {
                Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
                Field f = unsafeClass.getDeclaredField("theUnsafe");
                f.setAccessible(true);
                final Object unsafe = f.get(null);
                final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class);
                return new UnsafeAllocator() {
                    @Override
                    @SuppressWarnings("unchecked")
                    public <T> T newInstance(Class<T> c) throws Exception {
                        assertInstantiable(c);
                        return (T) allocateInstance.invoke(unsafe, c);
                    }
                };
            } catch (Exception ignored) {
            }
        }
        ```  
    - 从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。（没验证过）  
4. 模仿Gson中使用Unsafe绕过构造函数创建对象：  
    ```java
    public static void allocateInstance() {
        try {
            Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
            Field f = unsafeClass.getDeclaredField("theUnsafe");
            f.setAccessible(true);
            Object unsafe = f.get(null);
            Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class);
            Object man = allocateInstance.invoke(unsafe, Man.class);
            Log.e("lewis", "man.name=" + ((Man) man).getName());
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
    
    // log输出：man.name=null (并且没走Man的父类Human的构造函数)
    ```  
5. 绕过类的构造函数直接创建类的对象只是Unsafe的一个小功能，Unsafe类是提供给Java层的一个操作系统后门，可以直接对操作系统的内存等资源进行操作，即：增强了Java语言对底层资源操作的能力。既然可以像C/C++一样操作内存空间，使用Unsafe是比较高风险的，需要谨慎，下面简单描述下Unsafe的能力：  
6. **内存操作**：  
    - 主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法；  
    - 通常Java中创建的对象都位于堆内内存（heap），heap由JVM管控，是Java进程内存，遵循JVM垃圾回收机制；而Unsafe提供的接口是对 "对外内存"进行操作，不受JVM内存管理机制约束，所以使用不当很危险；  
    - 使用堆外内存的好处：1.改善垃圾回收时造成的停顿现象；2.提升I/O性能，通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存；  
    - 应用：nio包下的DirectByteBuffer是Java层使用堆外内存的具体实现，内部接口就是使用Unsafe实现的；  
7. **CAS**：  
    - CAS：实现并发算法时用到的一种技术，Compare And Swap；  
    - CAS操作包含3个操作数：内存值value、预期的原值old、新值new；  
    - 执行CAS操作时，比较value和old，如果value==old，则更新内存值value=new，否则根据具体的实现或进行自旋，或报错等等；  
    - CAS操作是一条CPU的原子指令（cmpxchg）；  
    - 应用：JUC包下的AtomicInteger.getAndAddInt()最终执行Unsafe.compareAndSwapInt()，底层就是通过CPU指令cmpxcg；还有Java AQS、CurrentHashMap等；  
8. **Class相关**：  
    - 提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&确保初始化等；  
    - 应用：从Java 8开始，JDK使用invokedynamic（JDK 7引入的运行动态语言的一条新的虚拟机指令）及VM Anonymous Class（一种模版机制）结合来实现Java语言层面上的Lambda表达式；  
9. **操作对象**：  
    - 对对象成员属性、非常规的实例化等操作（Unsafe.allocateInstance()等）；  
    - 常规的对象实例化：使用new关键字，如果Foo类只有有参构造函数，且没显示声明无参构造函数，则只能调用有参构造函数创建对象；  
    - 非常规对象实例化：上述Foo，可以使用Unsafe.allocateInstance()绕过JVM安全检查，直接调用Foo隐式的无参构造函数实例化对象；  
    - 应用：Gson反序列化；  
10. **线程调度**：  
    - 包括线程阻塞（park()）、唤醒（unpark()）、锁机制（Unsafe.monitorEnter()...）等方法；  
    - Java锁的核心类AQS；  
11. **获取系统信息**：
    - 获取系统相关信息：返回系统指针的大小、获取内存页的大小；  
    - 应用：nio包下的工具类Bits，DirectByteBuffer中使用了Bits；
12. **内存屏障**：  
    - 在Java 8中引入，用于定义内存屏障（），避免代码重排序；  
    - 应用：在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁ReentrantReadWriteLock的一个改进版本不阻塞写线程获得写锁，缓解"读多写少"时写线程"饥饿"现象，但使用有规则【TODO：可以研究下StampedLock】；  
13. **操作数组**：  
    - 主要提供与数据操作相关的arrayBaseOffset()与arrayIndexScale()这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置；  
    - 应用：AtomicIntegerArray；



### 4. 从ReentrantLock看AQS原理  

[AQS原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)  

简介：  
Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的；AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架；  



### 5. JVM内存模型
TODO: 


[Java核心技术 卷I]()  
[深入理解Android: Java虚拟机ART]()

[TOC]  

# Android类加载机制

> 在Java层面，有两类基础的方法可以创建对象：  
    1. 动态方式：Class.forName("com.android.Foo").newInstance() / XXClassLoader.loadClass("com.android.Foo").newInstance()；  
    2. 静态方式：使用new关键字；

- 大致流程：  
一个Java类在被使用前（即虚拟机在调用某个Java类的成员函数或成员变量时），如果这个类还没有加载到虚拟机进程，则需要先加载，然后对该类进行一些处理，直到该类的所有信息都准备好后，这个类才能被使用；  
- 类加载流程总结起来三大步：加载->链接（验证->准备->解析）->初始化；

## 1. Android类加载器类型介绍  
- Android类加载机制也遵循Java中的双亲委派模型，层级关系如图；  
![Android类加载器](https://github.com/JLewis1001/Notes/blob/main/1-pics/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png?raw=true)   
    - BootClassLoader：启动类加载器，用于加载 Zygote 进程已经预加载的基本类（预加载的类一般在/frameworks/base/config/preloaded-classes文件中配置，大概上万个，包括JDK和AndroidSDK中的一些基础类），我们在使用时只需从缓存中加载。这是基类 ClassLoader 的一个内部类，是包访问权限，所以应用程序无权直接访问；  
    - PathClassLoader：路径类加载器，这是基类 ClassLoader 中指定的系统类加载器，由 ClassLoader.getSystemClassLoader() 返回。我们的 Android 应用程序中的所有类都是由该其加载的；  
    - DexClassLoader：这是 Android 应用程序用于自定义类加载器的一般父类；  

## 2. 通过ClassLoader加载类
- 还是从Java层代码说起，先看Class.ForName()：  
    ``java
    public static Class<?> forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
        // 默认使用启动类加载器
        if (loader == null) {
            loader = BootClassLoader.getInstance();
        }
        Class<?> result;
        try {
            // 接着调用native方法创建类的Class对象
            result = classForName(name, initialize, loader);
        } catch (ClassNotFoundException e) {
            Throwable cause = e.getCause();
            if (cause instanceof LinkageError) {
                throw (LinkageError) cause;
            }
            throw e;
        }
        return result;
    }
    
    static native Class<?> classForName(String className, boolean shouldInitialize,
            ClassLoader classLoader) throws ClassNotFoundException;
    ```  
- 再看ClassLoader.loadClass()：  
    ```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // 通过类的全限定名称，从缓存中查找是否已经被加载，
            // 
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
    ```

## 3. 通过new关键字创建类的实例







[Java核心技术 卷I]()  
[深入理解Android: Java虚拟机ART]()

[TOC]  

# Android类加载机制

> 在Java层面，有两类基础的方法可以创建对象：  
    1. 动态方式：Class.forName("com.android.Foo").newInstance() / XXClassLoader.loadClass("com.android.Foo").newInstance()；  
    2. 静态方式：使用new关键字；

- 大致流程：  
一个Java类在被使用前（即虚拟机在调用某个Java类的成员函数或成员变量时），如果这个类还没有装载到虚拟机进程，则需要先装载，然后对该类进行一些处理，直到该类的所有信息都准备好后，这个类才能被使用；  
- JVM类加载流程总结起来三大步：加载->连接（验证->准备->解析）->初始化；
- 但是，ART虚拟机的实现中，三个阶段并不是顺序调用的，我们可以从类的状态中看到，整个过程可分为Load(ClassStatus::kLoaded)、Resolve(ClassStatus::kResolved)、Verify(ClassStatus::kVerified)和Initialized(ClassStatus::kInitialized)四个阶段；

## 1. Android类加载器类型介绍  
- Android类加载机制也遵循Java中的双亲委派模型，层级关系如图；  
![Android类加载器](https://github.com/JLewis1001/Notes/blob/main/1-pics/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png?raw=true)   
    - BootClassLoader：启动类加载器，用于加载 Zygote 进程已经预加载的基本类（预加载的类一般在/frameworks/base/config/preloaded-classes文件中配置，大概上万个，包括JDK和AndroidSDK中的一些基础类），我们在使用时只需从缓存中加载。这是基类 ClassLoader 的一个内部类，是包访问权限，所以应用程序无权直接访问；  
    - PathClassLoader：路径类加载器，这是基类 ClassLoader 中指定的系统类加载器，由 ClassLoader.getSystemClassLoader() 返回。我们的 Android 应用程序中的所有类都是由该其加载的；  
    - DexClassLoader：这是 Android 应用程序用于自定义类加载器的一般父类；  


## 2. Dex文件介绍
1. 是针对Android系统ARM架构CPU的一种对Class文件优化后的文件格式；  
2. 可以用javac，将Java源码编译成（多个）.class文件，再用Android D8编译器将多个.class文件编译成一个.dex文件；  
3. dex文件比class文件的优点：1）dex文件会去除合并的多个class文件之间的冗余信息；2）将多个.class文件合并，可以减少I/O操作的次数；  
4. 

## 3. 动态方式加载类
1. 还是从Java层代码说起，先看Class.ForName()：  
    ```java
    public static Class<?> forName(String className)
                throws ClassNotFoundException {
        Class<?> caller = Reflection.getCallerClass();
        // 可以看到，我们常用的方法，默认第二个参数initialize=true
        return forName(className, true, ClassLoader.getClassLoader(caller));
    }
    
    public static Class<?> forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
        // 默认使用启动类加载器
        if (loader == null) {
            loader = BootClassLoader.getInstance();
        }
        Class<?> result;
        try {
            // 接着调用native方法创建类的Class对象
            result = classForName(name, initialize, loader);
        } catch (ClassNotFoundException e) {
            Throwable cause = e.getCause();
            if (cause instanceof LinkageError) {
                throw (LinkageError) cause;
            }
            throw e;
        }
        return result;
    }
    
    static native Class<?> classForName(String className, boolean shouldInitialize,
            ClassLoader classLoader) throws ClassNotFoundException;
    ```  
2. 再看ClassLoader.loadClass()：  
    ```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // 通过类的全限定名称，从缓存中查找是否已经被加载，如果已经加载过，直接返回；否则交给父加载器去尝试加载
            // 其内部最终调用java.lang.VMClassLoader#findLoadedClass(ClassLoader cl, String name)去查找
            // 需要注意一点是，会传入加载该类的ClassLoader对象，如果是不同的ClassLoader，就算类的全限定一样，加载的类的Class对象将不是同一个
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // 如果依然找不到，说明该类是第一次被加载，该方法被子类重写
                    c = findClass(name);
                }
            }
            return c;
    }
    ```  
    上述代码的findClass(name)会被子类重写，下面以BootClassLoader为例介绍：  
    ```java
    class BootClassLoader extends ClassLoader {
        ...
    
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // 这里直接调用的Class类的native方法，需要去C层继续查找代码
            return Class.classForName(name, false, null);
        }
    }
    ```  
3. 从上述代码可以知道，Class.ForName()和ClassLoader.loadClass()最终都是调用了Class.classForName(name, initialize, null)这个native方法，并且第三个参数为ClassLoader且传入了null；但Class.ForName()会把类初始化，而ClassLoader.loadClass()不会；  
4. 上述native方法对应C层的代码在java_lang_Class.cc文件的静态方法Class_classForName()：  
    ```java
    static jclass Class_classForName(JNIEnv* env, jclass, jstring javaName, jboolean initialize,
                                 jobject javaLoader) {
      ...
      std::string descriptor(DotToDescriptor(name.c_str()));
      ...
      Handle<mirror::ClassLoader> class_loader(
          hs.NewHandle(soa.Decode<mirror::ClassLoader>(javaLoader)));
      ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
      
      // 通过Java类的全限定字符串，使用ClassLinker去查找【1】
      Handle<mirror::Class> c(
          hs.NewHandle(class_linker->FindClass(soa.Self(), descriptor.c_str(), class_loader)));
      if (c == nullptr) {
        ...
        // 如果没找到Class对象，则报错ClassNotFoundException并返回Java层一个null
        jthrowable cnfe = reinterpret_cast<jthrowable>(
            env->NewObject(WellKnownClasses::java_lang_ClassNotFoundException,
                           WellKnownClasses::java_lang_ClassNotFoundException_init,
                           javaName,
                           cause.get()));
        if (cnfe != nullptr) {
          env->Throw(cnfe);
        }
        return nullptr;
      }
      // 两种装载类的方法的区别在这里
      if (initialize) {
        class_linker->EnsureInitialized(soa.Self(), c, true, true);
      }
      return soa.AddLocalReference<jclass>(c.Get());
    }
    ```  
5. 接着看ClassLinker::FindClass()方法，实现在art/runtime/class_linker.cc文件中，下面代码只关注装载单个类的部分，数组暂不介绍：  
    ```c
    ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
                                             const char* descriptor,
                                             Handle<mirror::ClassLoader> class_loader) {
      ...
      const size_t hash = ComputeModifiedUtf8Hash(descriptor);
      // 先从已经装载的ClassTable缓存中查找
      ObjPtr<mirror::Class> klass = LookupClass(self, descriptor, hash, class_loader.Get());
      if (klass != nullptr) {
        return EnsureResolved(self, descriptor, klass);
      }
      // 此处说明该类没有被装载过，我们Java层传入的class_loader对象是null，所以会走到下面的判断内部
      if (descriptor[0] != '[' && class_loader == nullptr) {
        // 对于非数组类型的Class，此处会先从根加载器中查找
        // FindInClassPath()方法中，通过BootClassLoader从DexFile[]集合中，挨个查询待装载的类的描述符信息是否存在
        ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_);
        if (pair.second != nullptr) {
          return DefineClass(self,
                             descriptor,
                             hash,
                             ScopedNullHandle<mirror::ClassLoader>(),
                             *pair.first,
                             *pair.second);
        } else {
          // 从DexFile[]文件集合遍历后，依然没找到类描述符信息，直接抛出NoClassDefFoundError【2】
          ObjPtr<mirror::Throwable> pre_allocated =
              Runtime::Current()->GetPreAllocatedNoClassDefFoundError();
          self->SetException(pre_allocated);
          return nullptr;
        }
      }
      // 走查找数组类的流程，暂不介绍
      ...
      
      // 成功找到类的Class对象并返回
      return result_ptr;
    }
    ```  
6. 从上述FindClass()方法可以知道，从DexFile集合中没找到【当前类】的描述符信息，会直接报错NoClassDefFoundError；如果【当前类】的描述符信息可以找到，就会执行DefineClass()方法，该方法将开始从dex文件中加载这个类，其代码如下：  
    ```c
    ObjPtr<mirror::Class> ClassLinker::DefineClass(Thread* self,
                                               const char* descriptor,
                                               size_t hash,
                                               Handle<mirror::ClassLoader> class_loader,
                                               const DexFile& dex_file,
                                               const dex::ClassDef& dex_class_def) {
        StackHandleScope<3> hs(self);
        auto klass = hs.NewHandle<mirror::Class>(nullptr);
      
        ...
        // DexCache是和ClassLoader关联的
        ObjPtr<mirror::DexCache> dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());
        ...
        // 将当前Class对象和DexCache关联
        klass->SetDexCache(dex_cache);
        // 对类设置一些属性，例如访问修饰符等
        SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());
        ...
        // 先上锁，解决多线程访问的问题
        ObjectLock<mirror::Class> lock(self, klass);
        ...
        // 将该Class对象缓存到ClassLoader对应的ClassTable里，再次FindClass()时，先从ClassTable里找
        ObjPtr<mirror::Class> existing = InsertClass(descriptor, klass.Get(), hash);
        ...
        // 加载Class对象，是加载类中的成员变量和方法的地方，后续介绍【3】
        LoadClass(self, *new_dex_file, *new_class_def, klass);
        ...
        // 加载完当前类后，会继续从dex文件中，加载其父类和接口类【4】
        if (!LoadSuperAndInterfaces(klass, *new_dex_file)) {
          // Loading failed.
          if (!klass->IsErroneous()) {
            mirror::Class::SetStatus(klass, ClassStatus::kErrorUnresolved, self);
          }
          return nullptr;
        }
        ...
        auto interfaces = hs.NewHandle<mirror::ObjectArray<mirror::Class>>(nullptr);
        MutableHandle<mirror::Class> h_new_class = hs.NewHandle<mirror::Class>(nullptr);
        // 如果当前类和其所有父类/接口全部加载完毕，则开始连接
        if (!LinkClass(self, descriptor, klass, interfaces, &h_new_class)) {
          // Linking failed.
          if (!klass->IsErroneous()) {
            mirror::Class::SetStatus(klass, ClassStatus::kErrorUnresolved, self);
          }
          return nullptr;
        }
        ...
        // 如果连接成功，则将当前类的对象返回给上层
        // 最终返回给Class_classForName()方法，至于是否需要初始化，就看Class_classForName()传入的initialize是什么了
        return h_new_class.Get();
    }
    ```  
    > DexCache对象里缓存了dex文件中的内容，dex文件中的内容大部分是借助符号引用间接的获取目标信息，而DexCache缓存的是最终信息。例如dex文件中type_ids[]保存的是该dex里用到或自定义的数据类型对应名称在string_ids[]中的索引，而DexCache里保存了一个GcRoot\<Class\>\*数组，即解析好的Class对象；  
7. 接着看加载父类和接口类的方法LoadSuperAndInterfaces()：  
    ```c
    bool ClassLinker::LoadSuperAndInterfaces(Handle<mirror::Class> klass, const DexFile& dex_file) {
      const dex::ClassDef& class_def = dex_file.GetClassDef(klass->GetDexClassDefIndex());
      dex::TypeIndex super_class_idx = class_def.superclass_idx_;
      if (super_class_idx.IsValid()) {
        ...
      }
      const dex::TypeList* interfaces = dex_file.GetInterfacesList(class_def);
      if (interfaces != nullptr) {
        for (size_t i = 0; i < interfaces->Size(); i++) {
          dex::TypeIndex idx = interfaces->GetTypeItem(i).type_idx_;
          // 根据方法参数可知：通过type_idx从dex文件中找到这个类型的字符串描述符，然后通过字符串描述符找到对应的类，所以返回一个Class对象
          // 根据上下文可知，此场景为解析接口类，内部先从DexCache缓存中查找接口类，如果找不到就执行ClassLinker::DoResolveType()函数
          ObjPtr<mirror::Class> interface = ResolveType(idx, klass.Get());
          if (interface == nullptr) {
            DCHECK(Thread::Current()->IsExceptionPending());
            // 如果根据idx没找到对应的接口类，则返回false，会回到【4】位置
            return false;
          }
          ...
        }
      }
      // 此时将当前类标记为Loaded状态
      mirror::Class::SetStatus(klass, ClassStatus::kLoaded, nullptr);
      return true;
    }
    ```  
8. 继续看ClassLinker::DoResolveType()代码：  
    ```c
    ObjPtr<mirror::Class> ClassLinker::DoResolveType(dex::TypeIndex type_idx,
                                                 Handle<mirror::DexCache> dex_cache,
                                                 Handle<mirror::ClassLoader> class_loader) {
      Thread* self = Thread::Current();
      // 先从dex文件中根据index找到对应（根据上下文，此处是接口类）的描述符
      const char* descriptor = dex_cache->GetDexFile()->StringByTypeIdx(type_idx);
      // 通过描述符又执行FindClass()方法去查询接口类
      ObjPtr<mirror::Class> resolved = FindClass(self, descriptor, class_loader);
      if (resolved != nullptr) {
        ...
      } else {
        // 如果父类或接口类没有找到，则会走到这里并抛出异常
        // 把ClassNotFoundException转换成NoClassDefFoundError.
        StackHandleScope<1> hs(self);
        Handle<mirror::Throwable> cause(hs.NewHandle(self->GetException()));
        if (cause->InstanceOf(GetClassRoot(ClassRoot::kJavaLangClassNotFoundException, this))) {
          DCHECK(resolved == nullptr);  // No Handle needed to preserve resolved.
          self->ClearException();
          // 重点看这里【5】
          ThrowNoClassDefFoundError("Failed resolution of: %s", descriptor);
          self->GetException()->SetCause(cause.Get());
        }
      }
      return resolved;
    }
    ```
9. 整体流程研究完后，回到【3】所遗留的问题，看下ClassLinker::LoadClass()函数是怎么加载类的：  
    ```c
    【TODO】
    ```
10. 走完整个DefineClass()方法后，类的状态会更新为kStatusResolved，离该Class真正可用还有2个阶段，Verify和Initialize，有兴趣的可以根据代码自行研究；

## 4. 通过new关键字创建类的实例
1. 从Java层代码说起：  
    ```java
    public void newObject() {
        Object o = new Object();
    }
    ```  
2. 编译后看下class文件：  
    ```java
    public void newObject();
      descriptor: ()V
      flags: ACC_PUBLIC
      Code:
        stack=2, locals=2, args_size=1
           0: new           #2                  // class java/lang/Object
           3: dup
           4: invokespecial #1                  // Method java/lang/Object."<init>":()V
           7: astore_1
           8: return
        LineNumberTable:
          line 41: 0
          line 42: 8
    ```  
    可以看到执行了new这个字节码指令；  
3. 之前介绍synchronized知道，Android虚拟机有两种执行模式，下面先介绍解释执行的过程，入口函数定义在art/runtime/interpreter/interpreter_switch_impl-inl.h文件中，NEW_INSTANCE()方法，代码如下所示：  
    ```c
    ALWAYS_INLINE void NEW_INSTANCE() REQUIRES_SHARED(Locks::mutator_lock_) {
        ObjPtr<mirror::Object> obj = nullptr;
        // 先拿到待创建实例的类的Class对象
        ObjPtr<mirror::Class> c = ResolveVerifyAndClinit(dex::TypeIndex(inst->VRegB_21c()),
                                                         shadow_frame.GetMethod(),
                                                         self,
                                                         false,
                                                         do_access_check);
        if (LIKELY(c != nullptr)) {
          if (UNLIKELY(c->IsStringClass())) {
            ...
          } else {
            // 如果能成功拿到类的Class对象，就通过下面方法构造一个类型为mirror::Object的对象
            obj = AllocObjectFromCode<true>(
                c.Ptr(),
                self,
                Runtime::Current()->GetHeap()->GetCurrentAllocator());
          }
        }
        ...
      }
    ```
4. 接着看ResolveVerifyAndClinit()方法做了什么，该方法定义在art/runtime/entrypoints/entrypoint_utils-inl.h文件中：  
    ```c
    inline ObjPtr<mirror::Class> ResolveVerifyAndClinit(dex::TypeIndex type_idx,
                                                    ArtMethod* referrer,
                                                    Thread* self,
                                                    bool can_run_clinit,
                                                    bool verify_access) {
      ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
      // 通过idx解析类的Class对象klass，内部的流程在上面已经介绍过了
      ObjPtr<mirror::Class> klass = class_linker->ResolveType(type_idx, referrer);
      if (UNLIKELY(klass == nullptr)) {
        CHECK(self->IsExceptionPending());
        return nullptr;  // Failure - Indicate to caller to deliver exception
      }
      ...
      StackHandleScope<1> hs(self);
      Handle<mirror::Class> h_class(hs.NewHandle(klass));
      if (!class_linker->EnsureInitialized(self, h_class, true, true)) {
        CHECK(self->IsExceptionPending());
        return nullptr;  // Failure - Indicate to caller to deliver exception
      }
      return h_class.Get();
    }
    ```  
5. 机器码执行模式下的对象创建过程：  
【TODO】


## 5. 总结
- 一个Java类首次被使用时，虚拟机需要先将类装载，接着一系列处理，当类的Class对象Status处于Initialized状态时，才能被使用；  
- 不论动态还是静态方式创建一个对象，都需要先拿到类的Class对象klass，使用klass对象创建实例；  
- 通过类的描述符信息，先从缓存中查找类的Class对象是否已经被初始化完成，如果是则直接拿去创建实例；如果没有，则需要通过ClassLinker::DefineClass()作为初始化类的入口，使用类的描述符信息，从dex文件中，先加载自身，然后加载父类和接口类；  
- 不论是自身或是父类或接口类，只要有一个，通过描述符信息从dex文件中找不到，会报错NoClassDefFoundError；  



